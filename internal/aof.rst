Append Only File 模式 —— aof
===============================

预备知识： http://redis.io/topics/persistence 页面中关于 AOF 的部分。

AOF 写入是如何进行的？
-----------------------

三个阶段： 1）命令执行 2）缓存追加 3）文件写入

命令进入
^^^^^^^^^^

服务器像平常一样执行客户端送来的命令，
命令在执行之后都会检查服务器是否处于 AOF 模式，
如果是的话，
它们就会将命令和命令的参数传播到 AOF 文件，
这会引起以下两步的执行。

缓存追加
^^^^^^^^^^^

两个 buf 。

每当有命令进入时，
将输入的命令从对象形式（\ ``redisObject``\ ）转换回字符串形式（Redis 协议），
然后将字符串追加到 ``server.aof_buf`` 的末尾，
下次执行 ``flushAppendOnlyFile`` 时，
就会将缓存写入到文件。

如果当时还在进行 AOF 文件重写，
那么将字符串形式的命令也添加到 AOF 文件重写缓存中，
这样无论是当前正在使用的 AOF 文件（老 AOF 文件）
还是正在重写的 AOF （新 AOF 文件），
它们的数据都是相同的、同步的。

文件写入 
^^^^^^^^^^

``flushAppendOnlyFile`` 函数：

1. 将 AOF 缓存用 write 写入 aof 文件

2. 如果 AOF 模式是 ``AOF_FSYNC_ALWAYS`` （总是执行 ``fsync`` ），那么调用 fsync （会阻塞 Redis 主进程）；如果 AOF 模式为 ``AOF_FSYNC_EVERYSEC`` （每秒 ``fsync`` 一次），并且后台任务队列中没有 ``fsync`` 在等待，那么将 ``fsync`` 命令放到后台执行（不阻塞主进程）。

.. tip:: 
    每秒执行一次 ``fsync`` 可以在尽可能保证安全性的前提下，最大化性能。
    总是执行 ``fsync`` 模式会造成 Redis 主进程阻塞，降低性能。


AOF 读取是如何进行的？
--------------------------

AOF 文件里的内容全都是 Redis 协议，
读入程序创建一个 Redis 伪终端，
然后将 AOF 文件里的协议传给伪终端，
服务器执行伪终端传给它的命令（就像平时执行用户的命令一样），
从而重建 AOF 文件所保存的数据库。

在读入 AOF 文件期间，
服务器还会间隔性地处理外部客户端的请求，
因此 AOF 文件的命令和外部客户端的命令可能互相覆盖。
所以在服务器读取 AOF 文件时，
最好不要连接客户端，
以免影响 AOF 文件的还原效果。


AOF 重写是如何进行的？
-----------------------------

遍历所有数据库，
遍历所有键-值对，
将这些键-值对的当前状态通过 Redis 协议的形式写入到一个指定名字的临时文件里。

例子，一个列表 key 里有三个元素 ``1`` 、 ``3`` , ``9`` ，
它们以 ``RPUSH key 1`` 、 ``RPUSH key 3`` 和 ``RPUSH key 9`` 三个命令执行而成，
那么将协议内容 ``RPUSH key 1 3 9`` 写入到 AOF 文件，
这样重写后的 AOF 文件在不修改 ``key`` 的值的前提下，
节约了三倍的空间。

.. warning::

    TODO 整合协议内容，更详细地描述重建过程。

写入过程会阻塞主进程。

.. note::

    这个过程只会被 ``BGREWRITEAOF`` 调用，
    Redis 不会直接调用这个阻塞进程。


AOF 后台重写是如何进行的？
-----------------------------

主进程 fork 出一个子进程，
子进程创建一个临时文件，并执行上一节描述的 AOF 重写动作，
而主进程则继续接受请求，
并将请求追加到一个字符串缓存里。

子进程完成之后给主进程发送一个信号，
告知重写已完成。

Redis 在每次执行 serverCorn 的时候都会检查一次是否有信号到达（非阻塞 ``wait3`` ），
如果服务器状态表示正处于后台重写状态，
并且接到子进程的重写已完成信号，
那么主进程将 AOF 重写进行以来的所有新命令缓存追加到重写后的 AOF 文件里，
这就完成了所有新旧数据的同步，
然后，
主进程将临时文件改名，
代替旧的 AOF 文件，
至此，
AOF 后台重写执行完毕。

整个重写过程由子进程进行，
除了将缓存写入到新 AOF 文件的那段时间之外（为了保证安全性，这段时间的阻塞是必须的），
主进程都不会被阻塞。
