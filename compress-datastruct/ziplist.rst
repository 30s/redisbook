压缩列表 —— ziplist
========================

一个 ziplist 就是用一系列特殊编码的内存块构成的列表，
这个列表可以保存长度受限的字符串和整数，
包括：

- 字符串
    - 长度小于等于 63 的字符串
    - 长度小于等于 16383 的字符串
    - 长度大于等于 16384 ，小于等于 4294967295 的字符串

- 整数
    - 4 bit 长，介于 ``0`` 至 ``12`` 之间的无符号整数
    - 8 bit 长的有符号整合
    - 24 bit 长的有符号整数
    - ``int16_t`` 类型的整数
    - ``int32_t`` 类型的整数
    - ``int64_t`` 类型的整数


ziplist 的构成
---------------------

下图展示了一个典型的 ziplist 的各个构成部分：

::

    area        |<---- ziplist header ---->|<----------- entries ------------->|<-end->|

    size           32 bit   32 bit   16 bit    ?        ?        ?        ?      8 bit
                +---------+--------+-------+--------+--------+--------+--------+-------+
    component   | zlbytes | zltail | zllen | entry1 | entry2 |  ...   | entryN | zlend |
                +---------+--------+-------+--------+--------+--------+--------+-------+


列表的各个部分作用如下：

============= =====================================================================================================================================
部分            作用
============= =====================================================================================================================================
``zlbytes``     记录了整个列表所占用的内存字节数，依靠整个值，可以在不遍历整个列表的前提下，进行内存重分配。
``zltail``      记录了到达表尾实体的偏移量，有了这个偏移量，就可以在不遍历整个列表的前提下，对表尾进行处理。
``zllen``       记录了列表中实体的数量。因为这个值的长度仅为 ``uint16`` ，当实体的数量超过 ``2^16-2`` 时，需要遍历整个列表才能知道实际的实体数量。
``entryX``      列表所保存的实体，长度根据内容而定。
``zlend``       特殊值 ``255`` ，标记列表的末端。
============= =====================================================================================================================================

ziplist 模块定义了一些函数来操作这个列表：

======================== ============================================================================ ================
 函数名                    作用                                                                        算法复杂度
======================== ============================================================================ ================
 ``ziplistNew``          创建一个新的 ziplist                                                           :math:`O(1)`
 ``ziplistResize``       重新调整 ziplist 的内存大小                                                    :math:`O(N)`
 ``ziplistPush``         将一个包含给定元素的新实体插入到列表的表头或者表尾                             :math:`O(N)`
 ``zipEntry``            取出给定位置上的实体，并将它的属性保存到 ``zlentry`` 结构然后返回              :math:`O(1)`
 ``ziplistInsert``       将一个包含给定元素的新实体插入到给定位置                                       :math:`O(N)` 
 ``ziplistDelete``       删除给定位置上的实体                                                           :math:`O(N)`
 ``ziplistDeleteRange``  在给定索引上，连续进行多次删除                                                 :math:`O(N)`
 ``ziplistFind``         根据给定数据，在列表中查找包含这些数据的实体                                   :math:`O(N)`
 ``ziplistLen``          返回 ziplist 保存的实体数量                                                    :math:`O(N)`
 ``ziplistBlobLen``      以字节为单位，返回 ziplist 占用的内存大小                                      :math:`O(1)`
======================== ============================================================================ ================

``ziplistPush`` 、 ``ziplistInsert`` 、 ``ziplistDelete`` 这些只针对单个实体的函数，
本身并不会修改整个列表，
但是，因为 ziplist 由连续的内存块构成，
当对实体进行修改/添加/删除操作之后，
可能需要对整个列表进行内存移位，或者内存重分配，
因此，这些函数的复杂度都为 :math:`O(N)` 。

另外，因为 ziplist header 部分的长度总是固定的，因此处理表头实体的复杂度总是常数时间的；
而 zltail 记录了到表尾的偏移量，因此处理表尾实体的复杂度也是常数时间的。


ziplist 实体的构成
----------------------

一个 ziplist 可以包含多个实体（entry，类似于双端链表的节点），而每个实体可以划分为以下几个部分：

::

    area        |<------------------- entry -------------------->|

                +------------------+----------+--------+---------+ 
    component   | pre_entry_length | encoding | length | content |
                +------------------+----------+--------+---------+

以下几个小节将分别对这个四个部分进行介绍。


pre_entry_length
^^^^^^^^^^^^^^^^^^^

``pre_entry_length`` 记录了前一个实体的长度，通过这个值，可以进行指针计算，从而跳转到上一个实体。

::

    area      |<---- previous entry --->|<--------------- current entry ---------------->|

              +-------------------------+-----------------------------+--------+---------+
    memory    | ...                     | pre_entry_length | encoding | length | content |
              |                         |                  |          |        |         |
    value     |                         | 40               |    ?     |   ?    |    ?    |
              +-------------------------+-----------------------------+--------+---------+
              ^                         ^
    pointer   |                         |
              p = e - 40                e

上图展示了如何通过一个实体向前跳转到另一个实体：
用指向当前节点的指针 ``e`` ，减去 ``pre_entry_length`` 的值，得出的结果就是指向前一个实体的地址 ``p`` 。

根据编码方式的不同， ``pre_entry_length`` 域可能占用 ``1`` 字节或者 ``5`` 字节：

======== ====================================================================================================================
  长度        说明
======== ====================================================================================================================
1 字节    如果前一实体的长度小于 254 字节，那么只使用一个字节保存它的值。
5 字节    如果前一实体的长度大于等于 254 字节，那么将第 1 个字节的值设为 ``254`` ，然后用接下来的 4 个字节保存实际长度。
======== ====================================================================================================================

作为例子，以下是一个长度为 1 字节的 ``pre_entry_length`` 域，域的值为 ``128`` （二进制为 ``1100100`` ）：

::

    area        |<------------------- entry -------------------->|

    size            8 bit                ?        ?        ?
                +------------------+----------+--------+---------+ 
    component   | pre_entry_length | encoding | length | content |
                |                  |          |        |         |
    value       | 1100100          |          |        |         |
                +------------------+----------+--------+---------+

而以下则是一个长度为 5 字节的 ``pre_entry_length`` 域，其中前一节点的长度为 ``10086`` （二进制为 ``100111 01100110`` ）：

::

    area        |<-----------------------------------entry---------------------------------->|

    size            40 bit                                          ?        ?        ?
                +----------------------------------------------+----------+--------+---------+ 
    component   | pre_entry_length                             | encoding | length | content |
                |                                              |          |        |         |
    value       | 11111110 000000000 0000000 00100111 01100110 |          |        |         |
                +----------------------------------------------+----------+--------+---------+
                |<------->|<---------------------------------->|
                   8 bit                 4 byte (32bit)


encoding 和 length
^^^^^^^^^^^^^^^^^^^^^

``encoding`` 和 ``length`` 两个部分一起决定了 ``content`` 部分所保存的数据的类型（以及长度）。

``encoding`` 域的长度为两个位，它的值可以是 ``00`` 、 ``01`` 、 ``10`` 和 ``11`` ；
值 ``11`` 表示 ``content`` 部分保存着整数，
而其他三种值表示 ``content`` 部分保存着字符串。

``00`` 、 ``01`` 和 ``10`` 开头的字符串类型编码如下：

================================================ =========== ============================================================
编码                                              占用空间    content 部分保存的值
================================================ =========== ============================================================
``00bbbbbb``                                      1 byte       长度小于等于 63 字节的字符串。
``01bbbbbb xxxxxx``                               2 byte       长度小于等于 16383 字节的字符串。
``10____ aaaaaaaa bbbbbbbb cccccccc dddddddd``    5 byte       长度大于等于 16384 字节，小于等于 4294967295 的字符串值
================================================ =========== ============================================================

表格中的下划线 ``_`` 表示留空，而变量 ``b`` 、 ``x`` 等则代表实际的二进制数据，多个字节之间用空格隔开，方便阅读。

``11`` 开头的整数编码如下：

==================== ============== ============================================================
编码                  占用空间       content 部分保存的值
==================== ============== ============================================================
``11000000``            1 byte         ``int16_t`` 类型的整数
``11010000``            1 byte         ``int32_t`` 类型的整数
``11100000``            1 byte         ``int64_t`` 类型的整数
``11110000``            1 byte         24 bit 有符号整数
``11111110``            1 byte         8 bit 有符号整数
``1111xxxx``            1 byte         4 bit 无符号整数，介于 ``0`` 至 ``12`` 之间
==================== ============== ============================================================


content
^^^^^^^^^^

``content`` 部分保存着节点的内容，它的类型和长度由 ``encoding`` 和 ``length`` 决定。

以下是一个保存着字符串 ``hello world`` 的实体的例子：

::

    area      |<---------------------- entry ----------------------->|

    size        ?                  2 bit      6 bit    11 byte
              +------------------+----------+--------+---------------+
    component | pre_entry_length | encoding | length | content       |
              |                  |          |        |               |
    value     | ?                |    00    | 001011 | "hello world" |
              +------------------+----------+--------+---------------+

``encoding`` 域的值 ``00`` 表示这是一个长度小于等于 63 字节的字符串。 ``length`` 域给出了这个字符串的准确长度 —— ``11`` 字节。 ``content`` 则保存着字符串值 ``hello world`` 本身。

以下是另一个实体，它保存着整数 ``10086`` ：

::

    area      |<---------------------- entry ----------------------->|

    size        ?                  2 bit      6 bit    int16_t/16bit
              +------------------+----------+--------+---------------+
    component | pre_entry_length | encoding | length | content       |
              |                  |          |        |               |
    value     | ?                |    11    | 000000 | 10086         |
              +------------------+----------+--------+---------------+

``encoding`` 域的值 ``11`` 表示实体保存的是一个整数；
而 ``length`` 域的值 ``000000`` 表示这个实体的值的类型为 ``int16_t`` ；
最后， ``content`` 保存着整数值 ``10086`` 本身。


创建新 ziplist
--------------------


添加实体
--------------


删除实体
-------------


查找（向后查找）
------------------


查找（向前查找）
-------------------



